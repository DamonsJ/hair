#version 400 core

layout(isolines) in;

in vec3 position_tc[];

const int MAX_VERTICES = 64; // Max number of hair vertices

// Constants for applying noise to vertex positions.
const int NOISE_OCTAVES = 3;
const float NOISE_AMPLITUDE = 0.04;

uniform mat4 model, view, projection;
uniform vec3 vertexData[MAX_VERTICES];
uniform int numHairSegments;
uniform float groupWidth;

#define tess_x clamp(gl_TessCoord.x, 0.0, 1 - 1e-4)
#define tess_y gl_TessCoord.y

float rand( vec2 p )
{
    float h = dot(p,vec2(127.1,311.7));
    return -1.0 + 2.0*fract(sin(h)*(43758.5453123));
}

float noise( in vec2 p )
{
    vec2 i = floor( p );
    vec2 f = fract( p );
    vec2 u = f*f*(3.0-2.0*f);
    return mix( mix( rand( i + vec2(0.0,0.0) ),
                     rand( i + vec2(1.0,0.0) ), u.x),
                mix( rand( i + vec2(0.0,1.0) ),
                     rand( i + vec2(1.0,1.0) ), u.x), u.y);
}

float noiseWithOctaves( in vec2 p )
{
    float f = 0.0;
    for (int i = 0; i < NOISE_OCTAVES; i++) {
        float scale = pow(2.0, float(i));
        f += noise(5.0 * scale * gl_TessCoord.xy) / (2.0*scale);
    }
    return f;
}

void main()
{
    // Get vertex position from uniform data array.
    vec3 pos = vertexData[int(tess_x * (numHairSegments+1))];

    pos.x += groupWidth * (tess_y - 0.5); // Offset each hair.
    pos.x += NOISE_AMPLITUDE * noiseWithOctaves(gl_TessCoord.xy); // Apply noise to offset position.

    gl_Position = projection * view * model * vec4(pos, 1);
}
